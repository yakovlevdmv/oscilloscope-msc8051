 /*******************************************************
 * Copyright (C) Hlib Nekrasov (email:ganekrasov@edu.hse.ru)
 *
 * This file is part of Oscilloscope on MCU intel8051 project.
 *
 * This project can not be copied and/or distributed without the express
 * permission of Hlib Nekrasov
 *******************************************************/


//WARNING: This Font Require X-GLCD Lib.
//         You can not use it with MikroE GLCD Lib.

//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//MikroElektronika 2011
//http://www.mikroe.com

//GLCD FontName : Courier5x9
//GLCD FontSize : 5 x 9

const unsigned short Calibri6x7[] = {
        0x00, 0x00, 0x7E, 0x41, 0x41, 0x3F, 0x00,  // Code for char 0
        0x00, 0x00, 0x42, 0x41, 0x7F, 0x40, 0x00,  // Code for char 1
        0x00, 0x00, 0x42, 0x61, 0x59, 0x4E, 0x00,  // Code for char 2
        0x00, 0x00, 0x41, 0x49, 0x49, 0x37, 0x00,  // Code for char 3
        0x00, 0x00, 0x1C, 0x16, 0x11, 0x7F, 0x10,  // Code for char 4
        0x00, 0x00, 0x4F, 0x49, 0x49, 0x31, 0x00,  // Code for char 5
        0x00, 0x00, 0x3E, 0x49, 0x49, 0x39, 0x00,  // Code for char 6
        0x00, 0x00, 0x01, 0x61, 0x39, 0x0F, 0x03,  // Code for char 7
        0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00,  // Code for char 8
        0x00, 0x00, 0x4E, 0x49, 0x49, 0x3E, 0x00   // Code for char 9
        };

unsigned char const num0[] = {
          0x05, 0xFE, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFE, 0x00
};

unsigned char const num1[] = {
         0x05, 0x02, 0x01, 0x02, 0x01, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x01
};

unsigned char const num2[] = {
         0x05, 0x82, 0x01, 0x41, 0x01, 0x21, 0x01, 0x11, 0x01, 0x0E, 0x01
};

unsigned char const num3[] = {
         0x05, 0x82, 0x00, 0x01, 0x01, 0x11, 0x01, 0x11, 0x01, 0xEE, 0x00
};

unsigned char const num4[] = {
         0x05, 0x60, 0x00, 0x58, 0x00, 0x46, 0x01, 0xFF, 0x01, 0x40, 0x01
};

unsigned char const num5[] = {
         0x05, 0x9F, 0x00, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0xE1, 0x00
};

unsigned char const num6[] = {
         0x05, 0xFC, 0x00, 0x12, 0x01, 0x11, 0x01, 0x11, 0x01, 0xE0, 0x00
};

unsigned char const num7[] = {
         0x05, 0x03, 0x00, 0x81, 0x01, 0x61, 0x00, 0x19, 0x00, 0x07, 0x00
};

unsigned char const num8[] = {
         0x05, 0xEE, 0x00, 0x11, 0x01, 0x11, 0x01, 0x11, 0x01, 0xEE, 0x00
};

unsigned char const num9[] = {
         0x05, 0x0E, 0x00, 0x11, 0x01, 0x11, 0x01, 0x91, 0x00, 0x7E, 0x00
};

/*const int num9[] = {0b00000000,  //9
                     0b01110100,
                     0b01010100,
                     0b01010100,
                     0b01010100,
                     0b01010100,
                     0b00000000,
                     0b00000000};  */

const char *ch0 = "channel 0";
const char *ch1 = "channel 1";
const char *RESULT_STR = "ADC result: ";
const char *INPUT_STR = "ADC input: ";
const char *GAIN_STR = "Gain: ";
const char *CRLF = "\r\n";

const int LCD_X_LIMIT = 128;
const int LCD_Y_LIMIT = 64;
const float VREF = 4.096;

sbit CS at P2_0_bit;

//Установка битов для GLCD экрана
sbit LCD_CS1B at P2_2_bit;
sbit LCD_CS2B at P2_3_bit;
sbit LCD_RS   at P2_4_bit;
sbit LCD_RW   at P2_5_bit;
sbit LCD_EN   at P2_6_bit;
sbit LCD_RST  at P2_7_bit;


sbit LCD_D0 at P0_0_bit;
sbit LCD_D1 at P0_1_bit;
sbit LCD_D2 at P0_2_bit;
sbit LCD_D3 at P0_3_bit;
sbit LCD_D4 at P0_4_bit;
sbit LCD_D5 at P0_5_bit;
sbit LCD_D6 at P0_6_bit;
sbit LCD_D7 at P0_7_bit;

void setXAddress(int x) {
     LCD_EN = 0;
     LCD_RS = 0;
     LCD_RW = 0;

     x = x + 0b10111000;

     P0 = x;
     LCD_EN = 1;
}

void setYAddress(int y) {
     LCD_EN = 0;
     LCD_RS = 0;
     LCD_RW = 0;

     y = y + 0b01000000;

     P0 = y;
     LCD_EN = 1;
}

void setZAddress(int z) {
     LCD_EN = 0;
     LCD_RS = 0;
     LCD_RW = 0;

     z = z + 0b11000000;

     P0 = z;
     LCD_EN = 1;
}

void writeData(char _data) {
    LCD_EN = 0;
    LCD_RS = 1;
    LCD_RW = 0;

    P0 = _data;
    LCD_EN = 1;
}

int readData(int x, int y) {
    int buf = 0;
    int _cs = x / 64;
    LCD_EN = 0;
    LCD_RS = 1;
    LCD_RW = 1;

    setXAddress(y/8);
    setZAddress(0);

     if (_cs == 0 ) {
        LCD_CS1B = 0;
        LCD_CS2B = 1;
        setYAddress(x);
     } else {
        LCD_CS1B = 1;
        LCD_CS2B = 0;
        setYAddress(64 + (x % 64));
     }

    LCD_EN = 1;
    buf = P0;
    LCD_EN = 0;
    return buf;
}

void displayOn() {
    LCD_EN = 1;
    LCD_RS = 0;
    LCD_RW = 0;

    P0 = 0x3f;

    LCD_CS1B=0;
    LCD_CS2B=0;
}

void drawPoint(int x, int y, int flag) {
     int count = 0;
     int limit = 0;
     int mask = 0b00000001;
     int _cs = x / 64;
     if (flag == 1) {
          mask = 0b00000000;
     }
     setXAddress(y/8);

     if (_cs == 0 ) {
        LCD_CS1B = 0;
        LCD_CS2B = 1;
        setYAddress(x);
     } else {
        LCD_CS1B = 1;
        LCD_CS2B = 0;
        setYAddress(x % 64);
     }
     setZAddress(0);
     limit = y % 8;
     for (count = 0; count < limit - 1; count++) {
          mask = mask << 1;
     }
     if(y > 0) {
         mask = mask << 1;
     }
     writeData(mask);
     LCD_EN = 0;
}

void drawMask(int x, int y, int mask) {
     int count = 0;
     int limit = 0;
     int _cs = x / 64;
     setXAddress(y/8);

     if (_cs == 0 ) {
        LCD_CS1B = 0;
        LCD_CS2B = 1;
        setYAddress(x);
     } else {
        LCD_CS1B = 1;
        LCD_CS2B = 0;
        setYAddress(x % 64);
     }
     setZAddress(0);
     writeData(mask);
     LCD_EN = 0;
}

void drawVLine(int column) {
     int count = 0;
     int mask = 0b11111111;
     int _cs = column / 64;

     for(count = 0; count < 8; count++) {
       if (_cs == 0 ) {
          LCD_CS1B = 0;
          LCD_CS2B = 1;
          setYAddress(column);
       } else {
          LCD_CS1B = 1;
          LCD_CS2B = 0;
          setYAddress(column % 64);
       }
       setXAddress(count);
       setZAddress(0);
       writeData(mask);
     }

     LCD_EN = 0;
}

void resetPoint(int x, int y) {
     int mask = 0b00000000;
     int _cs = x / 64;
     setXAddress(y/8);

     if (_cs == 0 ) {
        LCD_CS1B = 0;
        LCD_CS2B = 1;
        setYAddress(x);
     } else {
        LCD_CS1B = 1;
        LCD_CS2B = 0;
        setYAddress(x % 64);
     }
     setZAddress(0);
     writeData(mask);
     LCD_EN = 0;
}

int clear(int limit_left, int limit_right) {
     int x,y;
     if (limit_left >= limit_right) return -1;

     for(x = limit_left; x < limit_right; x++) {
           for(y = 0; y <=64; y++) {
                  drawPoint(x, y, 1);
           }
     }
     return 0;
}

struct rcv_data {
       short first;
       short second;
       short third;
} *adc_data;

void initSPI() {
     SPCR = 0b01010001;
}

void rs232init() {
     PCON = 0x80;
     TMOD = 0x022;
     TCON = 0x40;
     SCON = 0x50;
     TH1 = 0x0F5;
     P3 = 0x003;
     TR1_bit=1;
}

void transmit(char b) {
     SBUF = b;
     while(TI_bit == 0) {}
     TI_bit = 0;

}

void transmitString(char* str) {
       char *p = &str[0];

       while (*p) {
            transmit(*(p++));
       }
}

void writeSPI(int _data) {
     SPDR = _data;
}


int readSPI() {
    int _data;
    _data = SPDR;
    return _data;
}

void delay() {
    Delay_ms(1000);
}

struct rcv_data adc_get_data(int channel) {
         struct rcv_data _data;
         int SPI_init_data = 0b11000000;
         if(channel == 0) {
                    SPI_init_data += 0b00000000;
         } else if(channel == 1) {
                    SPI_init_data += 0b00001000;
         } else if(channel == 2) {
                    SPI_init_data += 0b00010000;
         } else if(channel == 3) {
                    SPI_init_data += 0b00011000;
         }
         P0 = SPI_init_data;
         CS = 0;


         writeSPI(SPI_init_data);
         while(SPIF_bit != 1) {}
         _data.first = readSPI();

         writeSPI(0b00000000);
         while(SPIF_bit != 1) {}
         _data.second = readSPI();

         writeSPI(0b00000000);
         while(SPIF_bit != 1) {}
         _data.third = readSPI();

         CS = 1;

         return _data;
}

int getBit(int position, int byte) {
    return (byte >> position) & 1;
}

int parseADCValue(struct rcv_data *adc_data) {
    int result = 0b000000000000;
    int i = 0;
    //First byte
    result += getBit(0, adc_data->first);
    //Second byte
    for(i = 7; i >= 0; i--) {
          result <<= 1;
          result += getBit(i, adc_data->second);
    }
    //Third
    for (i = 7; i >=5; i--) {
        result <<= 1;
        result += getBit(i, adc_data->third);
    }
    
    return result;
}

float getInputValue(int _data) {
      return 4.096 * _data / 4096;
}

float getGain(int _data) {
      return 2. * (_data / 1000.);
}
 
/*
  Most of the Microcontrolleres having limited RAM, For Avoiding the Errors Not Enough RAM and Strings problem (const truncated) .
  You have to move the strings to ROM (FLASH program) memory, and there by save RAM.

  In MikroC
  if the string is declared as constant - compiler will move it to ROM
  This is the way in which const truncated problem can be solved if
  great number of strings was used that was located in RAM.

  Source: http://www.shibuvarkala.com/2009/02/how-to-use-rom-for-storing-data-in.html
*/
// Copying strings from ROM to RAM
void strConstCpy(char *dest, const char *source) {
     while(*source) {
           *dest++ = *source++;
     }
     *dest = 0 ;
}

void drawHighValue(int number) {
     int i, x;
     char numBuffer[10];
     char *p;
     IntToStr(number, numBuffer);
     
     //transmitString(numBuffer);
     
     p = &numBuffer[0];
     x = 95;
     while (*p) {

           if(*p == '9') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 9 + i]);
                          x = x + 1;
                   }

            } else if (*p == '8') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 8 + i]);
                          x = x + 1;
                   }
            }  else if (*p == '7') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 7 + i]);
                          x = x + 1;
                   }
            } else if (*p == '6') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 6 + i]);
                          x = x + 1;
                   }
            } else if (*p == '5') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 5 + i]);
                          x = x + 1;
                   }
            } else if (*p == '4') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 4 + i]);
                          x = x + 1;
                   }
            } else if (*p == '3') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 3 + i]);
                          x = x + 1;
                   }
            } else if (*p == '2') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 2 + i]);
                          x = x + 1;
                   }
            } else if (*p == '1') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 1 + i]);
                          x = x + 1;
                   }
            } else if (*p == '0') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 0 + i]);
                          x = x + 1;
                   }
            }
            transmit(*(p++));
     }
}

void clearHighValue() {
       int x;
       for(x = 95; x < 128; x++) {
            drawMask(x, 8, 0b00000000);

       }
}

void drawLine()

void main() {
     char textBuffer[15];
     int adc_result;
     int y = 0;
     int x = 0;
     float f = 0;

     initSPI();
     rs232init();

     CS = 1;
     Delay_us(1);

     //LCD
     displayOn();
     clear(0, 128);
     adc_result = 4000;
     drawVLine(92);


     while(1) {
              *adc_data = adc_get_data(0);
              adc_result = parseADCValue(adc_data);
              //clear(93, 128);
              clearHighValue();
              drawHighValue(adc_result);

              y = 64 - adc_result / LCD_Y_LIMIT;
              y = y - 1;
              drawPoint(x, y, 0);
              x = x + 1;
              if (x == 92) {
                    x = 0;
                    clear(0, 92);
              }
     }
}