 /*******************************************************
 * Copyright (C) Hlib Nekrasov (email:ganekrasov@edu.hse.ru)
 *
 * This file is part of Oscilloscope on MCU intel8051 project.
 *
 * This project can not be copied and/or distributed without the express
 * permission of Hlib Nekrasov
 *******************************************************/

 sbit CS at P2_0_bit;
//WARNING: This Font Require X-GLCD Lib.
//         You can not use it with MikroE GLCD Lib.

//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//MikroElektronika 2011
//http://www.mikroe.com

//GLCD FontName : Courier5x9
//GLCD FontSize : 5 x 9

const unsigned short Calibri6x7[] = {
        0x00, 0x00, 0x7E, 0x41, 0x41, 0x3F, 0x00,  // Code for char 0
        0x00, 0x00, 0x42, 0x41, 0x7F, 0x40, 0x00,  // Code for char 1
        0x00, 0x00, 0x42, 0x61, 0x59, 0x4E, 0x00,  // Code for char 2
        0x00, 0x00, 0x41, 0x49, 0x49, 0x37, 0x00,  // Code for char 3
        0x00, 0x00, 0x1C, 0x16, 0x11, 0x7F, 0x10,  // Code for char 4
        0x00, 0x00, 0x4F, 0x49, 0x49, 0x31, 0x00,  // Code for char 5
        0x00, 0x00, 0x3E, 0x49, 0x49, 0x39, 0x00,  // Code for char 6
        0x00, 0x00, 0x01, 0x61, 0x39, 0x0F, 0x03,  // Code for char 7
        0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00,  // Code for char 8
        0x00, 0x00, 0x4E, 0x49, 0x49, 0x3E, 0x00   // Code for char 9
        };
        
const unsigned short comma[] = {
        0x40, 0x30, 0x00, 0x00, 0x00,
        };

const char *ch0 = "channel 0";
const char *ch1 = "channel 1";
const char *RESULT_STR = "ADC result: ";
const char *INPUT_STR = "ADC input: ";
const char *GAIN_STR = "Gain: ";
const char *CRLF = "\r\n";

const int LCD_X_LIMIT = 128;
const int LCD_Y_LIMIT = 64;
const float VREF = 4.096;

struct rcv_data {
       short first;
       short second;
       short third;
} *adc_data;



//Установка битов для GLCD экрана
sbit LCD_CS1B at P2_2_bit;
sbit LCD_CS2B at P2_3_bit;
sbit LCD_RS   at P2_4_bit;
sbit LCD_RW   at P2_5_bit;
sbit LCD_EN   at P2_6_bit;
sbit LCD_RST  at P2_7_bit;


sbit LCD_D0 at P0_0_bit;
sbit LCD_D1 at P0_1_bit;
sbit LCD_D2 at P0_2_bit;
sbit LCD_D3 at P0_3_bit;
sbit LCD_D4 at P0_4_bit;
sbit LCD_D5 at P0_5_bit;
sbit LCD_D6 at P0_6_bit;
sbit LCD_D7 at P0_7_bit;

void setXAddress(int x) {
     LCD_EN = 0;
     LCD_RS = 0;
     LCD_RW = 0;

     x = x + 0b10111000;

     P0 = x;
     LCD_EN = 1;
}

void setYAddress(int y) {
     LCD_EN = 0;
     LCD_RS = 0;
     LCD_RW = 0;

     y = y + 0b01000000;

     P0 = y;
     LCD_EN = 1;
}

void setZAddress(int z) {
     LCD_EN = 0;
     LCD_RS = 0;
     LCD_RW = 0;

     z = z + 0b11000000;

     P0 = z;
     LCD_EN = 1;
}

void writeData(char _data) {
    LCD_EN = 0;
    LCD_RS = 1;
    LCD_RW = 0;

    P0 = _data;
    LCD_EN = 1;
}

void displayOn() {
    LCD_EN = 1;
    LCD_RS = 0;
    LCD_RW = 0;

    P0 = 0x3f;

    LCD_CS1B=0;
    LCD_CS2B=0;
}

void drawPoint(int x, int y, int flag) {
     int count = 0;
     int limit = 0;
     int mask = 0b00000001;
     int _cs = x / 64;
     if (flag == 1) {
          mask = 0b00000000;
     }
     setXAddress(y/8);

     if (_cs == 0 ) {
        LCD_CS1B = 0;
        LCD_CS2B = 1;
        setYAddress(x);
     } else {
        LCD_CS1B = 1;
        LCD_CS2B = 0;
        setYAddress(x % 64);
     }
     setZAddress(0);
     limit = y % 8;
     for (count = 0; count < limit - 1; count++) {
          mask = mask << 1;
     }
     if(y > 0) {
         mask = mask << 1;
     }
     writeData(mask);
     Delay_ms(1000);
     LCD_EN = 0;
}

void drawMask(int x, int y, int mask) {
     int _cs = x / 64;
     setXAddress(y/8);

     if (_cs == 0 ) {
        LCD_CS1B = 0;
        LCD_CS2B = 1;
        setYAddress(x);
     } else {
        LCD_CS1B = 1;
        LCD_CS2B = 0;
        setYAddress(x % 64);
     }
     setZAddress(0);
     writeData(mask);
     LCD_EN = 0;
}

void drawVLine(int column) {
     int count = 0;
     int mask = 0b11111111;
     int _cs = column / 64;

     for(count = 0; count < 8; count++) {
       if (_cs == 0 ) {
          LCD_CS1B = 0;
          LCD_CS2B = 1;
          setYAddress(column);
       } else {
          LCD_CS1B = 1;
          LCD_CS2B = 0;
          setYAddress(column % 64);
       }
       setXAddress(count);
       setZAddress(0);
       writeData(mask);
     }

     LCD_EN = 0;
}

int clear(int limit_left, int limit_right) {
     int x,y;
     if (limit_left >= limit_right) return -1;

     for(x = limit_left; x < limit_right; x++) {
           for(y = 0; y <=64; y=y+8) {
//                  drawPoint(x, y, 1);
                    drawMask(x,y, 0b00000000);
           }
     }
     return 0;
}



void initSPI() {
     SPCR = 0b01010011;
}

void rs232init() {
     PCON = 0x80;
     TMOD = 0x022;
     TCON = 0x40;
     SCON = 0x50;
     TH1 = 0x0F5;
     P3 = 0x003;
     TR1_bit=1;
}

void transmit(char b) {
     SBUF = b;
     while(TI_bit == 0) {}
     TI_bit = 0;

}

void transmitString(char* str) {
       char *p = &str[0];

       while (*p) {
            transmit(*(p++));
       }
}

void writeSPI(int _data) {
     SPDR = _data;
}


int readSPI() {
    int _data;
    _data = SPDR;
    return _data;
}

void delay() {
    Delay_ms(1000);
}

struct rcv_data adc_get_data(int channel) {
         struct rcv_data _data;
         int SPI_init_data = 0b11000000;
         if(channel == 0) {
                    SPI_init_data += 0b00000000;
         } else if(channel == 1) {
                    SPI_init_data += 0b00001000;
         } else if(channel == 2) {
                    SPI_init_data += 0b00010000;
         } else if(channel == 3) {
                    SPI_init_data += 0b00011000;
         }
         P0 = SPI_init_data;
         CS = 0;


         writeSPI(SPI_init_data);
         while(SPIF_bit != 1) {}
         _data.first = readSPI();

         writeSPI(0b00000000);
         while(SPIF_bit != 1) {}
         _data.second = readSPI();

         writeSPI(0b00000000);
         while(SPIF_bit != 1) {}
         _data.third = readSPI();

         CS = 1;

         return _data;
}

int getBit(int position, int byte) {
    return (byte >> position) & 1;
}

int parseADCValue(struct rcv_data *adc_data) {
    int result = 0b000000000000;
    int i = 0;
    //First byte
    result += getBit(0, adc_data->first);
    //Second byte
    for(i = 7; i >= 0; i--) {
          result <<= 1;
          result += getBit(i, adc_data->second);
    }
    //Third
    for (i = 7; i >=5; i--) {
        result <<= 1;
        result += getBit(i, adc_data->third);
    }
    
    return result;
}

float getInputValue(int _data) {
      return 4.096 * _data / 4096;
}

float getGain(int _data) {
      return 2. * (_data / 1000.);
}
 
/*
  Most of the Microcontrolleres having limited RAM, For Avoiding the Errors Not Enough RAM and Strings problem (const truncated) .
  You have to move the strings to ROM (FLASH program) memory, and there by save RAM.

  In MikroC
  if the string is declared as constant - compiler will move it to ROM
  This is the way in which const truncated problem can be solved if
  great number of strings was used that was located in RAM.

  Source: http://www.shibuvarkala.com/2009/02/how-to-use-rom-for-storing-data-in.html
*/
// Copying strings from ROM to RAM
void strConstCpy(char *dest, const char *source) {
     while(*source) {
           *dest++ = *source++;
     }
     *dest = 0 ;
}

// reverses a string 'str' of length 'len'
void reverse(char *str, int len)
{
    int i=0, j=len-1, temp;
    while (i<j)
    {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
        i++; j--;
    }
}

 // Converts a given integer x to string str[].  d is the number
 // of digits required in output. If d is more than the number
 // of digits in x, then 0s are added at the beginning.
int intToStr(int x, char str[], int d)
{
    int i = 0;
    while (x)
    {
        str[i++] = (x%10) + '0';
        x = x/10;
    }

    // If number of digits required is more, then
    // add 0s at the beginning
    while (i < d)
        str[i++] = '0';

    reverse(str, i);
    str[i] = '\0';
    return i;
}

// Converts a floating point number to string.
void ftoa(float n, char *res, int afterpoint)
{
    // Extract integer part
    int ipart = (int)n;

    // Extract floating part
    float fpart = n - (float)ipart;

    // convert integer part to string
    int i = intToStr(ipart, res, 0);

    // check for display option after point
    if (afterpoint != 0)
    {
        res[i] = '.';  // add dot

        // Get the value of fraction part upto given no.
        // of points after dot. The third parameter is needed
        // to handle cases like 233.007
        fpart = fpart * pow(10, afterpoint);

        intToStr((int)fpart, res + i + 1, afterpoint);
    }
}

void drawHighValue(float number) {
     int i, x;
     char numBuffer[10];
     char *p;
     
     ftoa(number, numBuffer, 2);

     p = &numBuffer[0];
     x = 95;
     while (*p) {

           if(*p == '9') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 9 + i]);
                          x = x + 1;
                   }

            } else if (*p == '8') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 8 + i]);
                          x = x + 1;
                   }
            }  else if (*p == '7') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 7 + i]);
                          x = x + 1;
                   }
            } else if (*p == '6') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 6 + i]);
                          x = x + 1;
                   }
            } else if (*p == '5') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 5 + i]);
                          x = x + 1;
                   }
            } else if (*p == '4') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 4 + i]);
                          x = x + 1;
                   }
            } else if (*p == '3') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 3 + i]);
                          x = x + 1;
                   }
            } else if (*p == '2') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 2 + i]);
                          x = x + 1;
                   }
            } else if (*p == '1') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 1 + i]);
                          x = x + 1;
                   }
            } else if (*p == '0') {
                   for(i = 0; i < 7; i++) {
                          drawMask(x, 8, Calibri6x7[7 * 0 + i]);
                          x = x + 1;
                   }
            } else if (*p == '.') {
                   for(i = 0; i < 5; i++) {
                          drawMask(x, 8, comma[i]);
                          x = x + 1;
                   }
            }
            (*(p++));

     }
}

void clearHighValue() {
       int x;
       for(x = 95; x < 128; x++) {
            drawMask(x, 8, 0b00000000);

       }
}

int Abs(int num) {
	if(num < 0)
		return -num;
	else
		return num;
}

void Brezenhem(int x0, int y0, int x1, int y1)
{
     int A, B, sign, signa, signb;
     int x, y;
     int f = 0;
     A = y1 - y0;
     B = x0 - x1;
     if (abs(A) > abs(B))
	sign = 1;
     else
	sign = -1;
     if (A < 0)
	  signa = -1;
     else
	  signa = 1;
     if (B < 0)
	  signb = -1;
     else
	  signb = 1;
     drawPoint(x0,y0, 0);
     x = x0;
     y = y0;
     if (sign == -1)
     {
      do {
         f += A*signa;
         if (f > 0)
         {
            f -= B*signb;
            y += signa;
         }
         x -= signb;
         drawPoint(x, y, 0);
    } while (x != x1 || y != y1);
  }
  else
  {
    do {
      f += B*signb;
      if (f > 0) {
        f -= A*signa;
        x -= signb;
      }
      y += signa;
      drawPoint(x, y, 0);
    } while (x != x1 || y != y1);
  }
}

void main() {
     char textBuffer[15];
     int adc_result;
     int y = 0;
     int x = 0;
     float inputValue = 0;
     float k = 0;
     int prevx;
     int prevy;
     
     prevx=0;
     prevy=0;

     initSPI();
     rs232init();

     CS = 1;
     Delay_us(1);

     //LCD
     displayOn();
     clear(0, 128);
     drawVLine(92);

     while(1) {
     drawPoint(1,1,0);
     drawPoint(1,40,0);
              Brezenhem(1, 1, 1, 40);
//              Brezenhem(10, 15, 17, 25);
              /**adc_data = adc_get_data(0);
              adc_result = parseADCValue(adc_data);
              inputValue = getInputValue(adc_result);
              
              y = 64 - adc_result / LCD_Y_LIMIT;
              y = y - 1;
              if(x == 0) {
                   prevx = x;
                   prevy = y;
              } else if (x > 0) {
                    Brezenhem(prevx, prevy, x, y);
                    prevx = x;
                    prevy = y;
              }
              //drawPoint(x, y, 0);
              x = x + 1;
              if (x == 92) {
                    x = 0;
                    clear(0, 92);
              }
              
              *adc_data = adc_get_data(1);
              adc_result = parseADCValue(adc_data);
              k = getGain(adc_result);
              k = inputValue * k;
              
              clear(93, 128);
              clearHighValue();
              drawHighValue(k); */


     }
}